## 数据结构和算法

### 时间复杂度和空间复杂度
  - 执行次数要分最好的情况和最坏的情况
  #### 时间复杂度
  - 时间复杂度衡量算法执行时间随着输入规模增加而增长的关系，是一种对算法的`分类`
    - O(n) / O(n+m) / O(n*m) / O(1)
  ```js
    // 执行次数  T = 3n + 4   
    function sum (a) {
      let sum = 0 // 1
      // 1 n+1 n
      for(let i=0; i< a.length; i++)  {
        sum += a[i] // 1n
      }
      return sum // 1
    }

    // 二维数组执行次数 T = 3n^2 + 4n + 4
    function sum2(A) {
      let sum = 0 // 1
      // 1 n+1 n
      for(let i = 0; i < A.length; i++) {
        // n n(n+1) n*n
        for(let j = 0; j < A[i].length; j++) {
          sum += A[i][j] // n*n
        }
      }
      return sum // 1
    }
    // 一维数组求和的算法，时间复杂度是O(n)
    // 二维数组求和的算法，时间复杂度是O(n^2)
    // 三维数组求和的算法，时间复杂度是O(n^3)
    // 四维数组求和的算法，时间复杂度是O(n^4)
  ```
  - O(n)
    - 一个for循环
  - O(n^2)
    - 嵌套for循环
  - 随着规模增长O(n^2)的算法比O(n)的算法增长更快
  - 在T = an^2 + bn + c的算法中，n^2起决定作用
  - 通常算法在更大输入集合的表现更有意义

  #### 空间复杂度
  - 指算法用了多少额外的空间
  ```js
  ```
  #### k分查找
    - 二分查找最好的情况下时间复杂度是O(1)
    - 二分查找最坏的情况下时间复杂度是O(log2n)
    - 二分查找的空间复杂度是O(1)
    - 三分查找时间复杂度是O(logn) ...

### 复杂度求和
  - 复杂度是度量`指标`随着输入规模增长关系的一种`分类`，描述的是随着输入规模增加算法中`最大的影响因子`
  - 算法在不同环境曲线类型相同，对T=an的算法，在不同CPU上表现出a不同，但是仍然是线性关系。因为本质上`规模`和`计算次数`是线性关系。
  - BIG-O的本质是一种渐进趋势的描述，渐进记号
    - 渐进上界O
    - 渐进紧密界
    - 渐进下界

  ```js
    O(1) + O(1) = O(1)
    O(n) + O(n) = O(n)
    O(lgn) + O(lgn) = O(lgn)
    O(lgn) + O(n) = O(n)
    O(n) + O(1) = O(n)

    // 降低复杂度
    // 分治策略
      O(n^2) -> O(nlgn)
    // 散列
      O(n) -> O(1)
      O(n) -> O(k)
    // 二叉树
      O(n) -> O(lgn)
    // 链表
      O(n) -> O(1)
    // 动态规划
      O(n!) -> O(n^2)
      O(2^n) -> O(n^2)

  ```