/* 
  1. JavaScript中的垃圾收集
    - 程序的运行需要内存，只要程序要求，操作系统就必须提供内存
    - JavaScript使用自动内存管理，这被称为‘垃圾回收机制’（garbage collector）
    - 优点是可以简化开发、节省代码
    - 缺点是无法完整的掌握内存的分配与回收的具体过程
  
  1.1 NodeJS中的内存管理
    - 网页端的内存泄漏
    - 对于持续运行的服务进程Node服务器端程序，必须及时释放不再用到的内存。否则内存越高，轻则影响系统性能，重则导致进程崩溃
    - 如果不再用到的内存没有及时释放，就叫做内存泄漏
  
  1.2 V8内存管理
    1.2.1 V8内存限制
      - 在64位操作系统可以使用1.4G内存
      - 在32位操作系统可以使用0.7G内存776iu iiuu j
    1.2.2 V8内存管理
      - JS对象都是通过V8进行分配管理内存的
      - process.memoryUsage() 返回一个对象，包含了Node进程的内存占用信息
        + rss(resident set size) 所有内存占用，包括指令区和堆栈
        + heapTotal '堆'占用的内存，包括用到和没用到的
        + heapUsed  用到的堆的部分。判断内存泄漏，以 heapUsed 字段为准
        + external  V8引擎内部的C++对象占用的内存
        { // Resident Set 多有内存占用
          { // 代码区域 Code Segment }
          { // 栈(stack)本地变量、指针 }
          { // 堆(HeapTotal) 对象、闭包
            { // heapUsed 使用到的堆 }
          }
        }
    1.2.3 为何限制内存大小
      - 因为V8的垃圾收集工作原理导致的，1.4G内存完全一次垃圾收集需要1秒以上
      - 这个暂停时间为 stop the world 在这个期间，应用的性能和响应能力都会下降
    1.2.4 如何打开内存限制
        - 一旦初始化成功，生效后不能再修改
        - -max-new-space-size 最大 new space 大小，执行scavenge回收，默认16M，单位KB
        - -max-old-space-size 最大 old space 大小，执行marksweep回收，默认1G，单位MB
*/
console.log(process.memoryUsage());
/* 
  {
    rss: 20267008,       20M
    heapTotal: 4333568,   4M
    heapUsed: 2479400,    2M
    external: 828318,
    arrayBuffers: 9898
  }
*/

/* 
  2. V8的垃圾回收机制
    - V8是基于分代的垃圾回收
    - 不同代来及回收机制也不一样
    - 按存活的时间分为新生代和老生代
    
    2.1 分代
      {
        { // 新生代
          {From},
          {To}
        },
        { // 老生代 }
      }
      - 年龄小的是新生代，由From区域和To区域两个区域组成
        + 64位系统，新生代内存是32M，From区域和To区域各占16M
        + 32位系统，新生代内存是16M，From区域和To区域各占8M
      - 年龄大的是老生代，默认情况
        + 64位系统下老生代内存是1400M
        + 32位系统下老生代内存是700M
    
    2.2 引用计数
      - 语言引擎由一张引用表，保存了内存里面所有资源的引用次数
      - 如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放

    2.2 新生代垃圾回收
      - 新生代区域一分为二，每个16M，一个使用一个空闲
      - 开始垃圾回收的时候，会检查From区域中的存活对象，如果还活着拷贝到To区域，完成后释放空间
      - 完成后 From 和 To 互换
      - 新生代扫描的时候是一种广度优先的扫描策略
        - 先遍历顶层数据，然后逐级向下层查找
      - 新生代的空间小，存活对象少
      - 当一个对象经历过多次的垃圾回收依然存活的时候，生存周期比较长的对象会被移动到老生代，这个移动过程被成为晋升或者升级
      - 经历5次以上的回收还存在
      - To的空间使用占比超过25% 或 超大对象
    
    2.3 老生代
      - mark-sweep(标记清除)
        - 清理完会生成碎片，碎片占会用空间，再插入大量数据可能会是失败
      - mark-compact(标记整理)
        - 移动对象，整理比较慢
      - 老生代空间大，大部分都是活着的对象，GC耗时比较长
      - 在GC期间无法响应，STOP-THE-WORLD
      - V8有一个优化方案，增量处理，把一个大暂停换成多个小暂停 increment-gc

      2.3.1 mark-sweep（标记清除）
        - 标记活着的对象，随后清除再标记阶段没有标记的对象，只清理死亡对象
        - 问题在于清除后会出现内存不连续的情况，这种内存碎片会对后续的内存分配产生影响
        - 如果分配一个大对象，碎片空间无法分配
      2.3.2 mark-compact（标记整理）
        - 标记死亡后会对对象进行整理，活着的对象向左移，移动完成后直接清理掉边界外的内存
      2.3.3 incremental marking 增量标记
        - 以上三种回收时都需要暂停程序执行，收集完成后才能恢复，STOP-THE-WORLD 在新生代影响不大，老生代影响很大
        - 增量标记就是吧标记改为了增量标记，把一口气停顿拆分成多个小步骤，做完一部程序运行一会，垃圾回收和应用程序交替进行，停顿时间可以减少到1/6左右

*/

function Person(name) {
  this.name = name
}
var p1 = new Person('test1') // Person实例1
var p2 = new Person('test2') // Person实例2
setTimeout(() => p1 = null, 1000) // 过1秒后释放p1的实例
setTimeout(() => p2 = null, 2000) // 过2秒后释放p2的实例，Person实例为0会释放

// 全局作用域定义的对象不会被销毁
